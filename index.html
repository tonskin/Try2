<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Lip Zoom-in Centered Demo</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/face_mesh.js"></script>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; height: 100%; background: #000;}
    body { width: 100vw; height: 100vh;}
    #output {
      position: absolute;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      object-fit: cover;
      z-index: 1;
    }
    #input_video { display: none; }
  </style>
</head>
<body>
  <video id="input_video"></video>
  <canvas id="output"></canvas>
  <script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output');
    const ctx = canvasElement.getContext('2d');

    function resizeCanvas() {
      canvasElement.width = window.innerWidth;
      canvasElement.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    async function setupCamera() {
      const stream = await navigator.mediaDevices.getUserMedia({video: {facingMode: "user"}});
      videoElement.srcObject = stream;
      await videoElement.play();
    }

    const faceMesh = new FaceMesh({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/${file}`
    });
    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    faceMesh.onResults(onResults);

    async function detectionFrame() {
      await faceMesh.send({image: videoElement});
      requestAnimationFrame(detectionFrame);
    }

    async function main() {
      await setupCamera();
      videoElement.onloadeddata = () => detectionFrame();
    }

    function onResults(results) {
      ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);

      if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) {
        // 畫面清空
        return;
      }
      // 嘴唇參考點 index（只取外圈 landmark，更專注於嘴唇外框）
      const lipsIndexes = [
        61, 146, 91, 181, 84, 17, 314, 405, 321, 375, 291, 61
      ];
      const points = lipsIndexes.map(i => results.multiFaceLandmarks[0][i]);
      // video 解析度
      const vw = videoElement.videoWidth;
      const vh = videoElement.videoHeight;

      // 將嘴唇點座標轉成 video 實際像素
      const pxs = points.map(pt => pt.x * vw);
      const pys = points.map(pt => pt.y * vh);

      // 嘴唇外框的矩形
      const minX = Math.min(...pxs), maxX = Math.max(...pxs);
      const minY = Math.min(...pys), maxY = Math.max(...pys);
      const centerX = (minX + maxX) / 2;
      const centerY = (minY + maxY) / 2;
      const lipW = (maxX - minX) * 2.2; // 2.2~2.5可根據版面調整
      const lipH = (maxY - minY) * 2.2;

      // 要抓的原圖範圍（以嘴唇中心為畫面中心，裁切一個較大的嘴唇區域，避免超過來源邊界）
      let srcX = Math.max(centerX - lipW/2, 0);
      let srcY = Math.max(centerY - lipH/2, 0);
      let srcW = Math.min(lipW, vw - srcX);
      let srcH = Math.min(lipH, vh - srcY);

      // 讓嘴唇區保持畫面比例
      const canvasAR = canvasElement.width / canvasElement.height;
      const lipAR = srcW / srcH;
      if (lipAR > canvasAR) {
        // 擴展高
        const wantH = srcW / canvasAR;
        srcY = Math.max(centerY - wantH/2, 0);
        srcH = Math.min(wantH, vh - srcY);
      } else {
        // 擴展寬
        const wantW = srcH * canvasAR;
        srcX = Math.max(centerX - wantW/2, 0);
        srcW = Math.min(wantW, vw - srcX);
      }

      // drawImage(來源, sx, sy, sw, sh, 目標, dx, dy, dw, dh)
      ctx.drawImage(
        videoElement,
        srcX, srcY, srcW, srcH,
        0, 0, canvasElement.width, canvasElement.height
      );

      // 可視化嘴唇紅框（可註解掉）
      /*
      ctx.save();
      ctx.strokeStyle = "red";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.rect(
        (centerX - lipW/2 - srcX) * (canvasElement.width / srcW),
        (centerY - lipH/2 - srcY) * (canvasElement.height / srcH),
        lipW * (canvasElement.width / srcW),
        lipH * (canvasElement.height / srcH)
      );
      ctx.stroke();
      ctx.restore();
      */
    }

    main();
  </script>
</body>
</html>
